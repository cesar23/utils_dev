#!/bin/bash
# Fecha y hora actual en formato: YYYY-MM-DD_HH:MM:SS (hora local)
DATE_HOUR=$(date "+%Y-%m-%d_%H:%M:%S")
# Fecha y hora actual en PerÃº (UTC -5)
HOURS_RESTART="-5"
DATE_HOUR_PE_DEFAULT=$(date -u -d "-5 hours" "+%Y-%m-%d_%H:%M:%S") # Fecha y hora actuales en formato YYYY-MM-DD_HH:MM:SS.
CURRENT_USER=$(id -un)             # Nombre del usuario actual.
CURRENT_USER_HOME="${HOME:-$USERPROFILE}"  # Ruta del perfil del usuario actual.
CURRENT_PC_NAME=$(hostname)        # Nombre del equipo actual.
MY_INFO="${CURRENT_USER}@${CURRENT_PC_NAME}"  # InformaciÃ³n combinada del usuario y del equipo.
PATH_SCRIPT=$(readlink -f "${BASH_SOURCE:-$0}")  # Ruta completa del script actual.
SCRIPT_NAME=$(basename "$PATH_SCRIPT")           # Nombre del archivo del script.
CURRENT_DIR=$(dirname "$PATH_SCRIPT")            # Ruta del directorio donde se encuentra el script.
NAME_DIR=$(basename "$CURRENT_DIR")              # Nombre del directorio actual.
TEMP_PATH_SCRIPT=$(echo "$PATH_SCRIPT" | sed 's/.sh/.tmp/g')  # Ruta para un archivo temporal basado en el nombre del script.
TEMP_PATH_SCRIPT_SYSTEM=$(echo "${TMP}/${SCRIPT_NAME}" | sed 's/.sh/.tmp/g')  # Ruta para un archivo temporal en /tmp.
ROOT_PATH=$(realpath -m "${CURRENT_DIR}/..")



# =============================================================================
# ğŸ¨ SECTION: Colores para su uso
# =============================================================================
# DefiniciÃ³n de colores que se pueden usar en la salida del terminal.

# Colores Regulares
Color_Off='\033[0m'       # Reset de color.
Black='\033[0;30m'        # Negro.
Red='\033[0;31m'          # Rojo.
Green='\033[0;32m'        # Verde.
Yellow='\033[0;33m'       # Amarillo.
Blue='\033[0;34m'         # Azul.
Purple='\033[0;35m'       # PÃºrpura.
Cyan='\033[0;36m'         # Cian.
White='\033[0;37m'        # Blanco.
Gray='\033[0;90m'         # Gris.

# Colores en Negrita
BBlack='\033[1;30m'       # Negro (negrita).
BRed='\033[1;31m'         # Rojo (negrita).
BGreen='\033[1;32m'       # Verde (negrita).
BYellow='\033[1;33m'      # Amarillo (negrita).
BBlue='\033[1;34m'        # Azul (negrita).
BPurple='\033[1;35m'      # PÃºrpura (negrita).
BCyan='\033[1;36m'        # Cian (negrita).
BWhite='\033[1;37m'       # Blanco (negrita).
BGray='\033[1;90m'        # Gris (negrita).

# Ejemplo de uso:
# echo -e "${Red}Este texto se mostrarÃ¡ en rojo.${Color_Off}"

# =============================================================================
# âš™ï¸ SECTION: Core Function
# =============================================================================

#=============================================================================
# FunciÃ³n: get_date_peru
#
# DescripciÃ³n:
#   Obtiene la fecha y hora actual de PerÃº desde una API externa.
#   La funciÃ³n realiza una llamada HTTP a un servicio de zona horaria
#   y extrae la fecha en formato yyyy-MM-dd_HH:mm:ss (con guiÃ³n bajo
#   como separador para compatibilidad con nombres de archivo).
#
# Variables de entorno:
#   API_TOKEN - Token de autenticaciÃ³n para la API (opcional, tiene fallback)
#
# Retorna:
#   0: Ã‰xito - Imprime la fecha en stdout en formato yyyy-MM-dd_HH:mm:ss
#   1: Error - Fallo en la conexiÃ³n o en el parseo de la respuesta
#
# Ejemplos de uso:
#
#   OpciÃ³n 1 - Manejo con valor por defecto (mÃ¡s conciso):
#   if ! FECHA=$(get_date_peru); then
#       FECHA="2025-01-01_00:00:00"
#   fi
#   echo "Fecha: $FECHA"
#
#   OpciÃ³n 2 - Manejo con mensajes de error:
#   if FECHA=$(get_date_peru); then
#       echo "Fecha obtenida: $FECHA"
#   else
#       echo "Error al obtener fecha" >&2
#       exit 1
#   fi
#=============================================================================
get_date_peru() {
    # ConfiguraciÃ³n del token de autenticaciÃ³n
    # Se prioriza la variable de entorno API_TOKEN por seguridad
    # Si no existe, usa el valor predeterminado (solo para desarrollo)
    local TOKEN="${API_TOKEN:-12312323rfefewfewfwefwef23r23r23f23f32f}"

    # ParÃ¡metros de la peticiÃ³n HTTP
    local API_URL="https://worker-utils.solucionessystem.com/api/time-zone/peru"
    local FORMATO_FECHA="yyyy-MM-dd%20HH%3Amm%3Ass"  # URL encoded: "yyyy-MM-dd HH:mm:ss"
    local TIMEOUT=10  # Timeout en segundos para la peticiÃ³n

    # Realizar llamada a la API con curl
    # Opciones:
    #   -s (silent): Suprime la barra de progreso
    #   --location: Sigue redirecciones HTTP
    #   --max-time: Tiempo mÃ¡ximo de espera para la operaciÃ³n completa
    local RESPONSE
    RESPONSE=$(curl -s --location \
        --max-time "$TIMEOUT" \
        "${API_URL}?key=${TOKEN}&format=${FORMATO_FECHA}") || {
        # Si curl falla (cÃ³digo de salida != 0), retornar error
        # Posibles causas: sin conexiÃ³n, timeout, servidor no responde
        return 1
    }

    # Parsear la respuesta JSON para extraer el campo "date_local"
    # MÃ©todo: Usa grep con regex para buscar el patrÃ³n y cut para extraer el valor
    # Ventaja: No requiere dependencias adicionales como jq
    # Ejemplo de JSON esperado: {"date_local":"2025-10-30 15:30:45"}
    local FECHA_HORA
    FECHA_HORA=$(echo "$RESPONSE" | grep -o '"date_local":"[^"]*"' | cut -d'"' -f4)

    # Validar que se extrajo correctamente la fecha
    if [ -z "$FECHA_HORA" ]; then
        # Si la extracciÃ³n falla, la respuesta no tiene el formato esperado
        # o el campo "date_local" no existe
        return 1
    fi

    # Reemplazar espacios por guiones bajos para compatibilidad
    # Ãštil cuando se usa la fecha en nombres de archivo o rutas
    FECHA_HORA=$(echo "$FECHA_HORA" | tr ' ' '_')

    # Retornar la fecha formateada
    echo "$FECHA_HORA"
    return 0
}
# funcion para saber si restaremos horas para obtener hora peru
set_hours_rest_peru(){

  # 2025-02-02_12:33:34  =  2025-02-02_12
  # El patrÃ³n ':*' busca el primer ':' y  lo que le sigue, eliminando ':33:34'.
  local DATE_HOUR_HOUR="${DATE_HOUR%:*}"
  local DATE_HOUR_PE_HOUR="${DATE_HOUR_PE%:*}"

  # Si las horas coinciden, no es necesario restar (la API ya devuelve hora correcta)
  if [[ "${DATE_HOUR_HOUR}" == "${DATE_HOUR_PE_HOUR}" ]]; then
      HOURS_RESTART="-0"
  fi
}



# ==============================================================================
# ğŸ“ FunciÃ³n: msg
# ------------------------------------------------------------------------------
# âœ… DescripciÃ³n:
#   Imprime un mensaje con formato estÃ¡ndar, incluyendo:
#   - Marca de tiempo en UTC-5 (PerÃº)
#   - Tipo de mensaje (INFO, WARNING, ERROR, o personalizado)
#   - Colores para terminal (si estÃ¡n definidos previamente)
#
# ğŸ”§ ParÃ¡metros:
#   $1 - Mensaje a mostrar (texto)
#   $2 - Tipo de mensaje (INFO | WARNING | ERROR | otro) [opcional, por defecto: INFO]
#
# ğŸ’¡ Uso:
#   msg "Inicio del proceso"               # Por defecto: INFO
#   msg "Plugin no instalado" "WARNING"
#   msg "Error de conexiÃ³n" "ERROR"
#   msg "Mensaje personalizado" "DEBUG"
#
# ğŸ¨ Requiere:
#   Variables de color: BBlue, BYellow, BRed, BWhite, BGray, Color_Off
# ==============================================================================

msg() {
  local message="$1"
  local level="${2:-INFO}"
#  local timestamp=$(date "+%Y-%m-%d %H:%M:%S")

  local timestamp=$(date -u -d "${HOURS_RESTART} hours" "+%Y-%m-%d %H:%M:%S")



  local SHOW_DETAIL=1
  if [ -n "$SO_SYSTEM" ] && [ "$SO_SYSTEM" = "termux" ]; then
    SHOW_DETAIL=0
  fi


  case "$level" in
    INFO)
        if [ "$SHOW_DETAIL" -eq 0 ]; then
          echo -e "${BBlue}[INFO]${Color_Off} ${message}"
        else
          echo -e "${BBlue}${timestamp} - [INFO]${Color_Off} ${message}"
        fi
        ;;
    WARNING)
        if [ "$SHOW_DETAIL" -eq 0 ]; then
          echo -e "${BYellow}[WARNING]${Color_Off} ${message}"
        else
          echo -e "${BYellow}${timestamp} - [WARNING]${Color_Off} ${message}"
        fi
        ;;
    DEBUG)
        if [ "$SHOW_DETAIL" -eq 0 ]; then
          echo -e "${BPurple}[DEBUG]${Color_Off} ${message}"
        else
          echo -e "${BPurple}${timestamp} - [DEBUG]${Color_Off} ${message}"
        fi
        ;;
    ERROR)
        if [ "$SHOW_DETAIL" -eq 0 ]; then
          echo -e "${BRed}[ERROR]${Color_Off} ${message}"
        else
          echo -e "${BRed}${timestamp} - [ERROR]${Color_Off} ${message}"
        fi
        ;;
    SUCCESS)
        if [ "$SHOW_DETAIL" -eq 0 ]; then
          echo -e "${BGreen}[SUCCESS]${Color_Off} ${message}"
        else
          echo -e "${BGreen}${timestamp} - ${BGreen}[SUCCESS]${Color_Off} ${message}"
        fi
        ;;
    *)
          echo -e "${BGray}[OTHER]${Color_Off} ${message}"
        ;;
  esac
}


pause_continue() {
  # DescripciÃ³n:
  #   Muestra un mensaje de pausa. Si se pasa un argumento, lo usa como descripciÃ³n del evento.
  #   Si no se pasa nada, se muestra un mensaje por defecto.
  #
  # Uso:
  #   pause_continue                         # Usa mensaje por defecto
  #   pause_continue "Se instalÃ³ MySQL"      # Muestra "Se instalÃ³ MySQL. Presiona..."

  if [ -n "$1" ]; then
    local mensaje="ğŸ”¹ $1. Presiona [ENTER] para continuar..."
  else
    local mensaje="âœ… Comando ejecutado. Presiona [ENTER] para continuar..."
  fi

  msg  "${Gray}"
  read -p "$mensaje"
  msg  "${Color_Off}"
}


# ----------------------------------------
# Function: detect_system
# Detects the operating system distribution.
# Returns:
#   - "termux"  -> If running in Termux
#   - "wsl"     -> If running on Windows Subsystem for Linux
#   - "ubuntu"  -> If running on Ubuntu/Debian-based distributions
#   - "redhat"  -> If running on Red Hat, Fedora, CentOS, Rocky, or AlmaLinux
#   - "gitbash" -> If running on Git Bash
#   - "unknown" -> If the system is not recognized
#
# Example usage:
#   system=$(detect_system)
#   echo "Detected system: $system"
# ----------------------------------------
detect_system() {
    if [ -f /data/data/com.termux/files/usr/bin/pkg ]; then
        echo "termux"
    elif grep -q Microsoft /proc/version; then
        echo "wsl"
    elif [ -f /etc/os-release ]; then
        # Lee el ID de /etc/os-release
        source /etc/os-release
        case $ID in
            ubuntu|debian)
                echo "ubuntu"
                ;;
            rhel|centos|fedora|rocky|almalinux)
                echo "redhat"
                ;;
            *)
                echo "unknown"
                ;;
        esac
    elif [ -n "$MSYSTEM" ]; then
        echo "gitbash"
    else
        echo "unknown"
    fi
}

# =============================================================================
# ğŸ”§ SECTION: Functions Utils
# =============================================================================


# =========================================
# string_slugify
# -----------------------------------------
# Convierte una cadena en un slug amigable para URLs.
# Permite controlar el formato de mayÃºsculas/minÃºsculas.
#
# Argumentos:
#   $1 (str): Cadena original.
#   $2 (str): Formato de capitalizaciÃ³n (opcional):
#       - "lower": todo minÃºsculas
#       - "upper": todo mayÃºsculas
#       - "capitalize": primera letra en mayÃºscula
#       - "title": primera letra de cada palabra en mayÃºscula
#       - "none" o vacÃ­o: conserva el formato original (por defecto)
#
# Retorna:
#   str: Cadena en formato slug.
#
# Ejemplos de uso:
#   texto="Â¡Hola Mundo! Este es un TÃ­tulo de Prueba 2024"
#   echo "$(string_slugify "$texto")"                # hola-mundo-este-es-un-titulo-de-prueba-2024
#   echo "$(string_slugify "$texto" lower)"          # hola-mundo-este-es-un-titulo-de-prueba-2024
#   echo "$(string_slugify "$texto" upper)"          # HOLA-MUNDO-ESTE-ES-UN-TITULO-DE-PRUEBA-2024
#   echo "$(string_slugify "$texto" capitalize)"     # Hola-mundo-este-es-un-titulo-de-prueba-2024
#   echo "$(string_slugify "$texto" title)"          # Hola-Mundo-Este-Es-Un-Titulo-De-Prueba-2024
#   echo "$(string_slugify "Mi_video_de prueba final")" # mi-video-de-prueba-final
#   echo "$(string_slugify "TÃ­tulo con acentos y Ã±")"   # titulo-con-acentos-y-n
#
#   # Usando el slug para nombrar archivos:
#   titulo="Mi Video de Prueba 2024!"
#   slug=$(string_slugify "$titulo")
#   yt-dlp -o "${slug}.%(ext)s" "URL_DEL_VIDEO"
#   # DescargarÃ¡ el video como: mi-video-de-prueba-2024.mp4
# =========================================
string_slugify() {
    local input="$1"
    local case="$2"

    # Validar parÃ¡metros
    [[ -z "$input" ]] && echo "" && return

    # Eliminar espacios iniciales y finales
    input="$(echo "$input" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"

    # Aplicar el formato de capitalizaciÃ³n
    case "$case" in
        lower)
            input="$(echo "$input" | tr '[:upper:]' '[:lower:]')"
            ;;
        upper)
            input="$(echo "$input" | tr '[:lower:]' '[:upper:]')"
            ;;
        capitalize)
            first="$(echo "${input:0:1}" | tr '[:lower:]' '[:upper:]')"
            rest="$(echo "${input:1}" | tr '[:upper:]' '[:lower:]')"
            input="$first$rest"
            ;;
        title)
            input="$(echo "$input" | awk '{for(i=1;i<=NF;i++){ $i=toupper(substr($i,1,1)) tolower(substr($i,2)) }}1')"
            ;;
        none|"")
            ;; # conservar original
        *)
            echo "Error: parÃ¡metro invÃ¡lido. Usa: lower, upper, capitalize, title o none."
            return 1
            ;;
    esac

    # Eliminar caracteres no deseados (solo letras, nÃºmeros, guiones y espacios)
    input="$(echo "$input" | sed 's/[^[:alnum:] _-]//g')"

    # Reemplazar espacios o guiones bajos mÃºltiples por un solo guion
    input="$(echo "$input" | sed -E 's/[[:space:]_]+/-/g')"

    # Eliminar guiones iniciales o finales
    input="$(echo "$input" | sed -E 's/^-+|-+$//g')"

    echo "$input"
}

# ==============================================================================
# ğŸ“ FunciÃ³n: verificar_dependencias
# ------------------------------------------------------------------------------
# âœ… DescripciÃ³n:
#   Verifica que las dependencias necesarias estÃ©n instaladas en el sistema.
#
# ğŸ”§ Dependencias:
#   - yt-dlp: Herramienta para descargar videos de YouTube
#
# ğŸ’¡ Uso:
#   verificar_dependencias
# ==============================================================================
verificar_dependencias() {
    if ! command -v yt-dlp &> /dev/null; then
        msg "yt-dlp no estÃ¡ instalado. Por favor instÃ¡lalo primero." "ERROR"
        msg "InstalaciÃ³n: pip install yt-dlp o visita https://github.com/yt-dlp/yt-dlp" "INFO"
        exit 1
    fi
}

# ==============================================================================
# ğŸ“ FunciÃ³n: validar_url
# ------------------------------------------------------------------------------
# âœ… DescripciÃ³n:
#   Valida que la URL proporcionada sea una URL vÃ¡lida de YouTube.
#
# ğŸ”§ ParÃ¡metros:
#   $1 - URL a validar
#
# ğŸ’¡ Uso:
#   validar_url "https://www.youtube.com/watch?v=..."
# ==============================================================================
validar_url() {
    local url="$1"
    if [[ ! "$url" =~ ^https?://(www\.)?(youtube\.com|youtu\.be) ]]; then
        msg "La URL no parece ser de YouTube" "WARNING"
        read -p "Â¿Continuar de todas formas? (s/n): " resp
        if [[ ! "$resp" =~ ^[sS]$ ]]; then
            msg "OperaciÃ³n cancelada por el usuario" "INFO"
            exit 0
        fi
    fi
}

# ==============================================================================
# ğŸ“ FunciÃ³n: leer_ultima_ruta
# ------------------------------------------------------------------------------
# âœ… DescripciÃ³n:
#   Lee la Ãºltima ruta de descarga guardada desde el archivo temporal.
#
# ğŸ”§ Variables globales:
#   TEMP_PATH_SCRIPT - Ruta del archivo temporal donde se guarda la Ãºltima ruta
#
# ğŸ’¡ Retorna:
#   La Ãºltima ruta guardada o una cadena vacÃ­a si no existe
#
# ğŸ’¡ Uso:
#   ultima_ruta=$(leer_ultima_ruta)
# ==============================================================================
leer_ultima_ruta() {
    if [[ -f "$TEMP_PATH_SCRIPT" ]]; then
        cat "$TEMP_PATH_SCRIPT"
    else
        echo ""
    fi
}

# ==============================================================================
# ğŸ“ FunciÃ³n: guardar_ultima_ruta
# ------------------------------------------------------------------------------
# âœ… DescripciÃ³n:
#   Guarda la ruta de descarga actual en el archivo temporal para usarla
#   como predeterminada en la prÃ³xima ejecuciÃ³n.
#
# ğŸ”§ ParÃ¡metros:
#   $1 - Ruta a guardar
#
# ğŸ”§ Variables globales:
#   TEMP_PATH_SCRIPT - Ruta del archivo temporal donde se guarda la ruta
#
# ğŸ’¡ Uso:
#   guardar_ultima_ruta "/path/to/downloads"
# ==============================================================================
guardar_ultima_ruta() {
    local ruta="$1"
    echo "$ruta" > "$TEMP_PATH_SCRIPT"
}

# ==============================================================================
# ğŸ“ FunciÃ³n: solicitar_ruta_descarga
# ------------------------------------------------------------------------------
# âœ… DescripciÃ³n:
#   Solicita al usuario una ruta de descarga personalizada o usa la predeterminada.
#   Crea el directorio si no existe.
#   Guarda la ruta seleccionada para usarla como predeterminada en el futuro.
#
# ğŸ”§ Variables globales:
#   DOWNLOADS_PATH - Ruta de descarga (se modifica si el usuario proporciona una nueva)
#
# ğŸ’¡ CaracterÃ­sticas:
#   - Permite usar "." para guardar en la ubicaciÃ³n actual
#   - Guarda la Ãºltima ruta utilizada en un archivo temporal
#   - Usa la Ãºltima ruta guardada como predeterminada
#
# ğŸ’¡ Uso:
#   solicitar_ruta_descarga
# ==============================================================================
solicitar_ruta_descarga() {
    # Intentar leer la Ãºltima ruta guardada
    local ultima_ruta=$(leer_ultima_ruta)

    # Si existe una Ãºltima ruta guardada, usarla como predeterminada
    if [[ -n "$ultima_ruta" ]] && [[ -d "$ultima_ruta" ]]; then
        DOWNLOADS_PATH="$ultima_ruta"
    fi

    echo ""
    echo -e "${BBlue}Ruta por defecto de la descarga${Color_Off}:"
    echo -e "  ${BYellow}${DOWNLOADS_PATH}${Color_Off}"
    echo -e "${Gray}--------------------------------------${Color_Off}"
    echo -e "${BBlue}(Opcional)${Color_Off}:"
    echo -e "${Gray}Puedes escribir '.' para guardar en la ubicaciÃ³n actual${Color_Off}"
    read -p "$(echo -e "${Gray}Cambiar ruta descarga o [ENTER]:${Color_Off} ")" input_path

    # Si el usuario ingresÃ³ algo
    if [[ -n "$input_path" ]]; then
        # Si es un punto, usar el directorio actual
        if [[ "$input_path" == "." ]]; then
            DOWNLOADS_PATH="$(pwd)"
        else
            DOWNLOADS_PATH="$input_path"
        fi
    fi

    # Crear el directorio si no existe
    if [[ ! -d "$DOWNLOADS_PATH" ]]; then
        echo -e "${BYellow}La carpeta no existe. Creando: ${BGreen}$DOWNLOADS_PATH${Color_Off}"
        if ! mkdir -p "$DOWNLOADS_PATH"; then
            msg "No se pudo crear el directorio: $DOWNLOADS_PATH" "ERROR"
            exit 1
        fi
    fi

    # Guardar la ruta para futuras ejecuciones
    guardar_ultima_ruta "$DOWNLOADS_PATH"

    echo -e "${BGreen}Descargando en: ${BWhite}$DOWNLOADS_PATH${Color_Off}"
}

extraer_url_video() {
    local url="$1"
    # Extrae solo la parte hasta el primer '&' (o toda la url si no hay '&')
    local base_url="${url%%&*}"
    echo "$base_url"
}

descargar_video() {
    local url="$1"
    solo_video=$(extraer_url_video "$url")

    msg "Obteniendo informaciÃ³n del video..." "INFO"
    # Obtener y mostrar el tÃ­tulo del video
    titulo_video=$(yt-dlp --get-title "$solo_video" 2>/dev/null)

    if [[ -z "$titulo_video" ]]; then
        msg "No se pudo obtener el tÃ­tulo del video. Verifica la URL." "ERROR"
        return 1
    fi

    msg "TÃ­tulo: ${titulo_video}" "INFO"
    titulo_video_format=$(string_slugify "$titulo_video" title)

    msg "Iniciando descarga del video..." "INFO"
    if yt-dlp -c -f "bestvideo+bestaudio" -o "${DOWNLOADS_PATH}/${titulo_video_format}.%(ext)s" "$solo_video"; then
        # find get name file
        file_name_path=$(find "${DOWNLOADS_PATH}" -type f -name "${titulo_video_format}*" | tail -n 1)
        if [[ -n "$file_name_path" ]]; then
            msg "Fichero descargado en: ${file_name_path}" "SUCCESS"
        else
            msg "Video descargado pero no se encontrÃ³ el archivo" "WARNING"
        fi
    else
        msg "Error al descargar el video" "ERROR"
        return 1
    fi

    pause_continue "Descarga completada"
    exit 0
}

descargar_playlist() {
    local url="$1"

    msg "Iniciando descarga de playlist..." "INFO"
    # yt-dlp -c -f "bestvideo+bestaudio" --yes-playlist -o "%(title)s.%(ext)s" "$url"
    if yt-dlp -c -f "bestvideo+bestaudio" --yes-playlist -o "${DOWNLOADS_PATH}/%(playlist_index)02d-%(title)s.%(ext)s" "$url"; then
        msg "Playlist descargado exitosamente" "SUCCESS"
    else
        msg "Error al descargar la playlist" "ERROR"
        return 1
    fi

    echo ""
    read -p "Â¿Deseas renombrar los archivos descargados a formato slug? (s/n): " resp
    if [[ "$resp" =~ ^[sS]$ ]]; then
        msg "Renombrando archivos a formato slug..." "INFO"
        local count=0
        for archivo in "${DOWNLOADS_PATH}"/*.{mp4,mkv,webm,flv}; do
            [ -e "$archivo" ] || continue
            nombre=$(basename "$archivo")
            extension="${nombre##*.}"
            base="${nombre%.*}"
            slug=$(string_slugify "$base" title)
            nuevo="${DOWNLOADS_PATH}/${slug}.${extension}"
            if [[ "$archivo" != "$nuevo" ]]; then
                echo "Renombrando: $nombre -> ${slug}.${extension}"
                mv "$archivo" "$nuevo"
                ((count++))
            fi
        done
        if [ $count -gt 0 ]; then
            msg "Renombrado completado: $count archivo(s)" "SUCCESS"
        else
            msg "No se encontraron archivos para renombrar" "WARNING"
        fi
    fi

    pause_continue "Descarga de playlist completada"
    exit 0
}

descargar_audio() {
    local url="$1"
    solo_audio=$(extraer_url_video "$url")

    msg "Obteniendo informaciÃ³n del audio..." "INFO"
    # Obtener y mostrar el tÃ­tulo del video
    titulo_audio=$(yt-dlp --get-title "$solo_audio" 2>/dev/null)

    if [[ -z "$titulo_audio" ]]; then
        msg "No se pudo obtener el tÃ­tulo del audio. Verifica la URL." "ERROR"
        return 1
    fi

    msg "TÃ­tulo: ${titulo_audio}" "INFO"
    titulo_audio_format=$(string_slugify "$titulo_audio" title)

    msg "Iniciando descarga del audio..." "INFO"
    if yt-dlp -c -f "bestaudio" --extract-audio --audio-format mp3 -o "${DOWNLOADS_PATH}/${titulo_audio_format}.%(ext)s" "$solo_audio"; then
        # find get name file
        file_name_path=$(find "${DOWNLOADS_PATH}" -type f -name "${titulo_audio_format}*" | tail -n 1)
        if [[ -n "$file_name_path" ]]; then
            msg "Fichero de audio descargado en: ${file_name_path}" "SUCCESS"
        else
            msg "Audio descargado pero no se encontrÃ³ el archivo" "WARNING"
        fi
    else
        msg "Error al descargar el audio" "ERROR"
        return 1
    fi

    pause_continue "Descarga completada"
    exit 0
}



# =============================================================================
# ğŸ”¥ SECTION: Main Code
# =============================================================================
# Seteamos la hora peru
if ! DATE_HOUR_PE=$(get_date_peru); then
    DATE_HOUR_PE="${DATE_HOUR_PE_DEFAULT}"
fi
# setea la variable (HOURS_RESTART) -5 o 0 a restar
set_hours_rest_peru


# Detectar sistema operativo
SO_SYSTEM=$(detect_system)
DOWNLOADS_PATH="${CURRENT_USER_HOME}/Downloads/youtube"


# si estamos en so de termux, cambiar la ruta de descarga
if [ -n "$SO_SYSTEM" ] && [ "$SO_SYSTEM" = "termux" ]; then
    DOWNLOADS_PATH="/storage/emulated/0/Download/youtube"
    mkdir -p $DOWNLOADS_PATH
fi




mkdir -p "$DOWNLOADS_PATH"

# Verificar que yt-dlp estÃ© instalado
verificar_dependencias

if [ $# -ne 1 ]; then
    msg "Uso: $0 '<URL de YouTube>'" "ERROR"
    exit 1
fi

url="$1"

# Validar que la URL sea de YouTube
validar_url "$url"

# Limpiar pantalla para mejor experiencia de usuario
clear

# Banner compacto optimizado para mÃ³viles
echo ""
echo -e "${BPurple}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${Color_Off}"
echo -e "${BPurple}â•‘${Color_Off}  ${BCyan}ğŸ“¹ Descarga Videos YouTube${Color_Off}         ${BPurple}â•‘${Color_Off}"
echo -e "${BPurple}â•‘${Color_Off}         ${BYellow}VersiÃ³n 3.5.0${Color_Off}              ${BPurple}â•‘${Color_Off}"
echo -e "${BPurple}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£${Color_Off}"
echo -e "${BPurple}â•‘${Color_Off} ${Gray}ğŸ‘¤ Autor:${Color_Off} ${BWhite}Cesar Auris${Color_Off}               ${BPurple}â•‘${Color_Off}"
echo -e "${BPurple}â•‘${Color_Off} ${Gray}ğŸŒ Web:${Color_Off} ${BCyan}solucionessystem.com${Color_Off}        ${BPurple}â•‘${Color_Off}"
echo -e "${BPurple}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${Color_Off}"
echo ""

while true; do
    echo -e "${BBlue}Selecciona una opciÃ³n:${Color_Off}"
    echo -e "${BYellow}1)${Color_Off} Descargar solo el video"
    echo -e "${BYellow}2)${Color_Off} Descargar playlist completo"
    echo -e "${BYellow}3)${Color_Off} Descargar solo el audio"
    echo -e "${BYellow}4)${Color_Off} Salir"
    read -p "OpciÃ³n: " opcion

    case $opcion in
        1)
            solicitar_ruta_descarga
            descargar_video "$url"
            ;;
        2)
            solicitar_ruta_descarga
            descargar_playlist "$url"
            ;;
        3)
            solicitar_ruta_descarga
            descargar_audio "$url"
            ;;
        4)
            echo -e "${BRed}Saliendo...${Color_Off}"
            exit 0
            ;;
        *)
            echo -e "${BRed}OpciÃ³n no vÃ¡lida.${Color_Off}"
            ;;
    esac
done