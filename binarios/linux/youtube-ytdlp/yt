#!/bin/bash
# ============================================================================
# Script de Descarga de Videos de YouTube - Versi¨®n Mejorada
# Autor: Cesar Auris
# Web: solucionessystem.com
# Versi¨®n: 4.0.0
# ============================================================================

# =============================================================================
# ?? SECTION: Variables Globales y Configuraci¨®n
# =============================================================================

VERSION_SCRIPT="4.0.0"

# Fecha y hora actual en formato: YYYY-MM-DD_HH:MM:SS (hora local)
DATE_HOUR=$(date "+%Y-%m-%d_%H:%M:%S")
# Fecha y hora actual en Per¨² (UTC -5)
HOURS_RESTART="-5"
DATE_HOUR_PE_DEFAULT=$(date -u -d "-5 hours" "+%Y-%m-%d_%H:%M:%S")
CURRENT_USER=$(id -un)
CURRENT_USER_HOME="${HOME:-$USERPROFILE}"
CURRENT_PC_NAME=$(hostname)
MY_INFO="${CURRENT_USER}@${CURRENT_PC_NAME}"
PATH_SCRIPT=$(readlink -f "${BASH_SOURCE:-$0}")
SCRIPT_NAME=$(basename "$PATH_SCRIPT")
CURRENT_DIR=$(dirname "$PATH_SCRIPT")
NAME_DIR=$(basename "$CURRENT_DIR")
TEMP_PATH_SCRIPT=$(echo "$PATH_SCRIPT" | sed 's/.sh/.tmp/g')
TEMP_PATH_SCRIPT_SYSTEM=$(echo "${TMP}/${SCRIPT_NAME}" | sed 's/.sh/.tmp/g')
ROOT_PATH=$(realpath -m "${CURRENT_DIR}/..")

# Archivos de configuraci¨®n
CONFIG_DIR="${CURRENT_USER_HOME}/.yt-downloader"
HISTORIAL_FILE="${CONFIG_DIR}/historial.txt"
CONFIG_FILE="${CONFIG_DIR}/config.txt"
LAST_PATH_FILE="${CONFIG_DIR}/last_path.txt"

# Crear directorio de configuraci¨®n si no existe
mkdir -p "$CONFIG_DIR"

# Variables para configuraci¨®n de descarga
FORMATO_VIDEO="bestvideo+bestaudio"
FORMATO_AUDIO="mp3"
SUBTITULOS_PARAMS=""

# =============================================================================
# ?? SECTION: Colores para su uso
# =============================================================================

# Colores Regulares
Color_Off='\033[0m'
Black='\033[0;30m'
Red='\033[0;31m'
Green='\033[0;32m'
Yellow='\033[0;33m'
Blue='\033[0;34m'
Purple='\033[0;35m'
Cyan='\033[0;36m'
White='\033[0;37m'
Gray='\033[0;90m'

# Colores en Negrita
BBlack='\033[1;30m'
BRed='\033[1;31m'
BGreen='\033[1;32m'
BYellow='\033[1;33m'
BBlue='\033[1;34m'
BPurple='\033[1;35m'
BCyan='\033[1;36m'
BWhite='\033[1;37m'
BGray='\033[1;90m'

# =============================================================================
# ?? SECTION: Core Functions
# =============================================================================

get_date_peru() {
    local TOKEN="${API_TOKEN:-12312323rfefewfewfwefwef23r23r23f23f32f}"
    local API_URL="https://worker-utils.solucionessystem.com/api/time-zone/peru"
    local FORMATO_FECHA="yyyy-MM-dd%20HH%3Amm%3Ass"
    local TIMEOUT=10

    local RESPONSE
    RESPONSE=$(curl -s --location --max-time "$TIMEOUT" "${API_URL}?key=${TOKEN}&format=${FORMATO_FECHA}") || {
        return 1
    }

    local FECHA_HORA
    FECHA_HORA=$(echo "$RESPONSE" | grep -o '"date_local":"[^"]*"' | cut -d'"' -f4)

    if [ -z "$FECHA_HORA" ]; then
        return 1
    fi

    FECHA_HORA=$(echo "$FECHA_HORA" | tr ' ' '_')
    echo "$FECHA_HORA"
    return 0
}

set_hours_rest_peru(){
    local DATE_HOUR_HOUR="${DATE_HOUR%:*}"
    local DATE_HOUR_PE_HOUR="${DATE_HOUR_PE%:*}"

    if [[ "${DATE_HOUR_HOUR}" == "${DATE_HOUR_PE_HOUR}" ]]; then
        HOURS_RESTART="-0"
    fi
}

msg() {
    local message="$1"
    local level="${2:-INFO}"
    local timestamp=$(date -u -d "${HOURS_RESTART} hours" "+%Y-%m-%d %H:%M:%S")

    local SHOW_DETAIL=1
    if [ -n "$SO_SYSTEM" ] && [ "$SO_SYSTEM" = "termux" ]; then
        SHOW_DETAIL=0
    fi

    case "$level" in
        INFO)
            if [ "$SHOW_DETAIL" -eq 0 ]; then
                echo -e "${BBlue}[INFO]${Color_Off} ${message}"
            else
                echo -e "${BBlue}${timestamp} - [INFO]${Color_Off} ${message}"
            fi
            ;;
        WARNING)
            if [ "$SHOW_DETAIL" -eq 0 ]; then
                echo -e "${BYellow}[WARNING]${Color_Off} ${message}"
            else
                echo -e "${BYellow}${timestamp} - [WARNING]${Color_Off} ${message}"
            fi
            ;;
        DEBUG)
            if [ "$SHOW_DETAIL" -eq 0 ]; then
                echo -e "${BPurple}[DEBUG]${Color_Off} ${message}"
            else
                echo -e "${BPurple}${timestamp} - [DEBUG]${Color_Off} ${message}"
            fi
            ;;
        ERROR)
            if [ "$SHOW_DETAIL" -eq 0 ]; then
                echo -e "${BRed}[ERROR]${Color_Off} ${message}"
            else
                echo -e "${BRed}${timestamp} - [ERROR]${Color_Off} ${message}"
            fi
            ;;
        SUCCESS)
            if [ "$SHOW_DETAIL" -eq 0 ]; then
                echo -e "${BGreen}[SUCCESS]${Color_Off} ${message}"
            else
                echo -e "${BGreen}${timestamp} - ${BGreen}[SUCCESS]${Color_Off} ${message}"
            fi
            ;;
        *)
            echo -e "${BGray}[OTHER]${Color_Off} ${message}"
            ;;
    esac
}

pause_continue() {
    if [ -n "$1" ]; then
        local mensaje="?? $1. Presiona [ENTER] para continuar..."
    else
        local mensaje="? Comando ejecutado. Presiona [ENTER] para continuar..."
    fi

    msg "${Gray}"
    read -p "$mensaje"
    msg "${Color_Off}"
}

detect_system() {
    if [ -f /data/data/com.termux/files/usr/bin/pkg ]; then
        echo "termux"
    elif grep -q Microsoft /proc/version 2>/dev/null; then
        echo "wsl"
    elif [ -f /etc/os-release ]; then
        source /etc/os-release
        case $ID in
            ubuntu|debian)
                echo "ubuntu"
                ;;
            rhel|centos|fedora|rocky|almalinux)
                echo "redhat"
                ;;
            *)
                echo "unknown"
                ;;
        esac
    elif [ -n "$MSYSTEM" ]; then
        echo "gitbash"
    else
        echo "unknown"
    fi
}

string_slugify() {
    local input="$1"
    local case="$2"

    [[ -z "$input" ]] && echo "" && return

    input="$(echo "$input" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"

    case "$case" in
        lower)
            input="$(echo "$input" | tr '[:upper:]' '[:lower:]')"
            ;;
        upper)
            input="$(echo "$input" | tr '[:lower:]' '[:upper:]')"
            ;;
        capitalize)
            first="$(echo "${input:0:1}" | tr '[:lower:]' '[:upper:]')"
            rest="$(echo "${input:1}" | tr '[:upper:]' '[:lower:]')"
            input="$first$rest"
            ;;
        title)
            input="$(echo "$input" | awk '{for(i=1;i<=NF;i++){ $i=toupper(substr($i,1,1)) tolower(substr($i,2)) }}1')"
            ;;
        none|"")
            ;;
        *)
            echo "Error: par¨¢metro inv¨¢lido. Usa: lower, upper, capitalize, title o none."
            return 1
            ;;
    esac

    input="$(echo "$input" | sed 's/[^[:alnum:] _-]//g')"
    input="$(echo "$input" | sed -E 's/[[:space:]_]+/-/g')"
    input="$(echo "$input" | sed -E 's/^-+|-+$//g')"

    echo "$input"
}

# =============================================================================
# ?? SECTION: Nuevas Funcionalidades
# =============================================================================

verificar_espacio_disco() {
    local ruta="$1"
    local espacio_libre_kb=$(df -k "$ruta" 2>/dev/null | awk 'NR==2 {print $4}')
    local espacio_libre_gb=$((espacio_libre_kb / 1024 / 1024))
    
    msg "Espacio disponible: ${espacio_libre_gb}GB" "INFO"
    
    if [ "$espacio_libre_gb" -lt 1 ]; then
        msg "??  ADVERTENCIA: Menos de 1GB de espacio libre" "WARNING"
        read -p "?Continuar de todas formas? (s/n): " resp
        if [[ ! "$resp" =~ ^[sS]$ ]]; then
            msg "Operaci¨®n cancelada por el usuario" "INFO"
            return 1
        fi
    fi
    
    return 0
}

guardar_historial() {
    local url="$1"
    local titulo="$2"
    local tipo="$3"
    local fecha=$(date "+%Y-%m-%d %H:%M:%S")
    
    echo "${fecha}|${tipo}|${titulo}|${url}" >> "$HISTORIAL_FILE"
    msg "Descarga registrada en historial" "DEBUG"
}

verificar_descarga_previa() {
    local url="$1"
    
    if [ ! -f "$HISTORIAL_FILE" ]; then
        return 1
    fi
    
    if grep -q "$url" "$HISTORIAL_FILE"; then
        msg "??  Esta URL ya fue descargada anteriormente" "WARNING"
        local ultima_descarga=$(grep "$url" "$HISTORIAL_FILE" | tail -1)
        local fecha=$(echo "$ultima_descarga" | cut -d'|' -f1)
        local titulo=$(echo "$ultima_descarga" | cut -d'|' -f3)
        
        echo -e "${Gray}¨²ltima descarga: ${fecha}${Color_Off}"
        echo -e "${Gray}T¨ªtulo: ${titulo}${Color_Off}"
        
        read -p "?Descargar nuevamente? (s/n): " resp
        if [[ ! "$resp" =~ ^[sS]$ ]]; then
            return 0
        fi
    fi
    
    return 1
}

mostrar_info_video() {
    local url="$1"
    
    msg "Obteniendo informaci¨®n del video..." "INFO"
    
    local info=$(yt-dlp --print "%(title)s|||%(duration_string)s|||%(filesize_approx)s|||%(uploader)s" "$url" 2>/dev/null)
    
    if [ -z "$info" ]; then
        msg "No se pudo obtener informaci¨®n del video" "ERROR"
        return 1
    fi
    
    local titulo=$(echo "$info" | cut -d'|' -f1)
    local duracion=$(echo "$info" | cut -d'|' -f4)
    local tamano=$(echo "$info" | cut -d'|' -f7)
    local autor=$(echo "$info" | cut -d'|' -f10)
    
    if [ -n "$tamano" ] && [ "$tamano" != "NA" ] && [ "$tamano" != "" ]; then
        local tamano_mb=$((tamano / 1024 / 1024))
        tamano="${tamano_mb}MB"
    else
        tamano="Desconocido"
    fi
    
    echo ""
    echo -e "${BCyan}¨X¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨[${Color_Off}"
    echo -e "${BCyan}¨U${Color_Off}     ${BWhite}INFORMACI¨®N DEL VIDEO${Color_Off}             ${BCyan}¨U${Color_Off}"
    echo -e "${BCyan}¨d¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨g${Color_Off}"
    echo -e "${BCyan}¨U${Color_Off} ${Gray}?? T¨ªtulo:${Color_Off}"
    echo -e "${BCyan}¨U${Color_Off}    ${BWhite}${titulo:0:35}${Color_Off}"
    echo -e "${BCyan}¨U${Color_Off} ${Gray}?? Autor:${Color_Off} ${BYellow}${autor}${Color_Off}"
    echo -e "${BCyan}¨U${Color_Off} ${Gray}??  Duraci¨®n:${Color_Off} ${BGreen}${duracion}${Color_Off}"
    echo -e "${BCyan}¨U${Color_Off} ${Gray}?? Tama?o aprox:${Color_Off} ${BPurple}${tamano}${Color_Off}"
    echo -e "${BCyan}¨^¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨a${Color_Off}"
    echo ""
    
    return 0
}

seleccionar_calidad_video() {
    echo ""
    echo -e "${BBlue}Selecciona la calidad de descarga:${Color_Off}"
    echo -e "${BYellow}1)${Color_Off} Mejor calidad disponible (recomendado)"
    echo -e "${BYellow}2)${Color_Off} 1080p"
    echo -e "${BYellow}3)${Color_Off} 720p"
    echo -e "${BYellow}4)${Color_Off} 480p"
    echo -e "${BYellow}5)${Color_Off} 360p"
    echo -e "${BYellow}6)${Color_Off} Peor calidad (menor tama?o)"
    read -p "Opci¨®n [1]: " calidad_opcion
    
    case ${calidad_opcion:-1} in
        1)
            FORMATO_VIDEO="bestvideo+bestaudio"
            ;;
        2)
            FORMATO_VIDEO="bestvideo[height<=1080]+bestaudio/best[height<=1080]"
            ;;
        3)
            FORMATO_VIDEO="bestvideo[height<=720]+bestaudio/best[height<=720]"
            ;;
        4)
            FORMATO_VIDEO="bestvideo[height<=480]+bestaudio/best[height<=480]"
            ;;
        5)
            FORMATO_VIDEO="bestvideo[height<=360]+bestaudio/best[height<=360]"
            ;;
        6)
            FORMATO_VIDEO="worstvideo+worstaudio/worst"
            ;;
        *)
            FORMATO_VIDEO="bestvideo+bestaudio"
            ;;
    esac
    
    msg "Formato seleccionado: ${FORMATO_VIDEO}" "DEBUG"
}

descargar_con_reintentos() {
    local comando="$1"
    local max_intentos=3
    local intento=1
    
    while [ $intento -le $max_intentos ]; do
        msg "Intento $intento de $max_intentos..." "INFO"
        
        if eval "$comando"; then
            msg "Descarga completada exitosamente" "SUCCESS"
            return 0
        else
            if [ $intento -lt $max_intentos ]; then
                msg "Error en la descarga. Reintentando en 5 segundos..." "WARNING"
                sleep 5
            else
                msg "Error: Se agotaron los intentos de descarga" "ERROR"
                return 1
            fi
        fi
        
        ((intento++))
    done
    
    return 1
}

seleccionar_formato_audio() {
    echo ""
    echo -e "${BBlue}Selecciona el formato de audio:${Color_Off}"
    echo -e "${BYellow}1)${Color_Off} MP3 (recomendado)"
    echo -e "${BYellow}2)${Color_Off} M4A"
    echo -e "${BYellow}3)${Color_Off} OPUS"
    echo -e "${BYellow}4)${Color_Off} WAV"
    read -p "Opci¨®n [1]: " formato_opcion
    
    case ${formato_opcion:-1} in
        1) FORMATO_AUDIO="mp3" ;;
        2) FORMATO_AUDIO="m4a" ;;
        3) FORMATO_AUDIO="opus" ;;
        4) FORMATO_AUDIO="wav" ;;
        *) FORMATO_AUDIO="mp3" ;;
    esac
    
    msg "Formato de audio seleccionado: ${FORMATO_AUDIO}" "DEBUG"
}

configurar_subtitulos() {
    read -p "?Descargar subt¨ªtulos? (s/n) [n]: " resp_sub
    
    if [[ "$resp_sub" =~ ^[sS]$ ]]; then
        SUBTITULOS_PARAMS="--write-auto-sub --sub-lang es,en --convert-subs srt --embed-subs"
        msg "Subt¨ªtulos activados (ES, EN)" "INFO"
    else
        SUBTITULOS_PARAMS=""
    fi
}

# =============================================================================
# ?? SECTION: Funciones de Descarga
# =============================================================================

verificar_dependencias() {
    if ! command -v yt-dlp &> /dev/null; then
        msg "yt-dlp no est¨¢ instalado. Por favor inst¨¢lalo primero." "ERROR"
        msg "Instalaci¨®n: pip install yt-dlp o visita https://github.com/yt-dlp/yt-dlp" "INFO"
        exit 1
    fi
    
    local version=$(yt-dlp --version 2>/dev/null)
    msg "Usando yt-dlp versi¨®n: ${version}" "DEBUG"
}

validar_url() {
    local url="$1"
    if [[ ! "$url" =~ ^https?://(www\.)?(youtube\.com|youtu\.be) ]]; then
        msg "La URL no parece ser de YouTube" "WARNING"
        read -p "?Continuar de todas formas? (s/n): " resp
        if [[ ! "$resp" =~ ^[sS]$ ]]; then
            msg "Operaci¨®n cancelada por el usuario" "INFO"
            exit 0
        fi
    fi
}

leer_ultima_ruta() {
    if [[ -f "$LAST_PATH_FILE" ]]; then
        cat "$LAST_PATH_FILE"
    else
        echo ""
    fi
}

guardar_ultima_ruta() {
    local ruta="$1"
    echo "$ruta" > "$LAST_PATH_FILE"
}

solicitar_ruta_descarga() {
    local ultima_ruta=$(leer_ultima_ruta)

    if [[ -n "$ultima_ruta" ]] && [[ -d "$ultima_ruta" ]]; then
        DOWNLOADS_PATH="$ultima_ruta"
        echo ""
        echo -e "${BCyan}¨X¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨[${Color_Off}"
        echo -e "${BCyan}¨U${Color_Off}  ${BWhite}?? UBICACI¨®N DE DESCARGA${Color_Off}           ${BCyan}¨U${Color_Off}"
        echo -e "${BCyan}¨^¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨a${Color_Off}"
        echo -e "${BBlue}¨²ltima ubicaci¨®n utilizada:${Color_Off}"
        echo -e "  ${BYellow}${DOWNLOADS_PATH}${Color_Off}"
        echo ""
        read -p "$(echo -e "${Gray}?Deseas cambiar la ruta? (s/n) [n]:${Color_Off} ")" cambiar_ruta
        
        if [[ "$cambiar_ruta" =~ ^[sS]$ ]]; then
            echo ""
            read -p "$(echo -e "${Gray}Nueva ruta de descarga (o '.' para carpeta actual):${Color_Off} ")" input_path
            
            if [[ -n "$input_path" ]]; then
                if [[ "$input_path" == "." ]]; then
                    DOWNLOADS_PATH="$(pwd)"
                else
                    DOWNLOADS_PATH="$input_path"
                fi
            fi
        fi
    else
        echo ""
        echo -e "${BBlue}Ruta por defecto de la descarga${Color_Off}:"
        echo -e "  ${BYellow}${DOWNLOADS_PATH}${Color_Off}"
        echo -e "${Gray}--------------------------------------${Color_Off}"
        echo -e "${BBlue}(Opcional)${Color_Off}:"
        echo -e "${Gray}Puedes escribir '.' para guardar en la ubicaci¨®n actual${Color_Off}"
        read -p "$(echo -e "${Gray}Cambiar ruta descarga o [ENTER]:${Color_Off} ")" input_path

        if [[ -n "$input_path" ]]; then
            if [[ "$input_path" == "." ]]; then
                DOWNLOADS_PATH="$(pwd)"
            else
                DOWNLOADS_PATH="$input_path"
            fi
        fi
    fi

    if [[ ! -d "$DOWNLOADS_PATH" ]]; then
        echo -e "${BYellow}La carpeta no existe. Creando: ${BGreen}$DOWNLOADS_PATH${Color_Off}"
        if ! mkdir -p "$DOWNLOADS_PATH"; then
            msg "No se pudo crear el directorio: $DOWNLOADS_PATH" "ERROR"
            exit 1
        fi
    fi

    guardar_ultima_ruta "$DOWNLOADS_PATH"
    
    verificar_espacio_disco "$DOWNLOADS_PATH" || exit 1

    echo -e "${BGreen}? Descargando en: ${BWhite}$DOWNLOADS_PATH${Color_Off}"
}

extraer_url_video() {
    local url="$1"
    local base_url="${url%%&*}"
    echo "$base_url"
}

descargar_video() {
    local url="$1"
    local solo_video=$(extraer_url_video "$url")
    
    if verificar_descarga_previa "$solo_video"; then
        msg "Operaci¨®n cancelada - Video ya descargado previamente" "INFO"
        return 0
    fi
    
    mostrar_info_video "$solo_video" || return 1
    
    seleccionar_calidad_video
    
    configurar_subtitulos
    
    titulo_video=$(yt-dlp --get-title "$solo_video" 2>/dev/null)
    
    if [[ -z "$titulo_video" ]]; then
        msg "No se pudo obtener el t¨ªtulo del video. Verifica la URL." "ERROR"
        return 1
    fi
    
    titulo_video_format=$(string_slugify "$titulo_video" title)
    
    msg "Iniciando descarga del video..." "INFO"
    
    local comando="yt-dlp -c -f \"${FORMATO_VIDEO}\" ${SUBTITULOS_PARAMS} --progress --newline -o \"${DOWNLOADS_PATH}/${titulo_video_format}.%(ext)s\" \"$solo_video\""
    
    if descargar_con_reintentos "$comando"; then
        file_name_path=$(find "${DOWNLOADS_PATH}" -type f -name "${titulo_video_format}*" | tail -n 1)
        if [[ -n "$file_name_path" ]]; then
            msg "Fichero descargado en: ${file_name_path}" "SUCCESS"
            guardar_historial "$solo_video" "$titulo_video" "VIDEO"
        else
            msg "Video descargado pero no se encontr¨® el archivo" "WARNING"
        fi
    else
        return 1
    fi
    
    pause_continue "Descarga completada"
}

descargar_playlist() {
    local url="$1"
    
    msg "Obteniendo informaci¨®n de la playlist..." "INFO"
    
    seleccionar_calidad_video
    
    configurar_subtitulos
    
    msg "Iniciando descarga de playlist..." "INFO"
    
    local comando="yt-dlp -c -f \"${FORMATO_VIDEO}\" ${SUBTITULOS_PARAMS} --yes-playlist --progress --newline -o \"${DOWNLOADS_PATH}/%(playlist_index)02d-%(title)s.%(ext)s\" \"$url\""
    
    if descargar_con_reintentos "$comando"; then
        msg "Playlist descargado exitosamente" "SUCCESS"
        guardar_historial "$url" "PLAYLIST" "PLAYLIST"
    else
        return 1
    fi
    
    echo ""
    read -p "?Deseas renombrar los archivos descargados a formato slug? (s/n): " resp
    if [[ "$resp" =~ ^[sS]$ ]]; then
        msg "Renombrando archivos a formato slug..." "INFO"
        local count=0
        for archivo in "${DOWNLOADS_PATH}"/*.{mp4,mkv,webm,flv}; do
            [ -e "$archivo" ] || continue
            nombre=$(basename "$archivo")
            extension="${nombre##*.}"
            base="${nombre%.*}"
            slug=$(string_slugify "$base" title)
            nuevo="${DOWNLOADS_PATH}/${slug}.${extension}"
            if [[ "$archivo" != "$nuevo" ]]; then
                echo "Renombrando: $nombre -> ${slug}.${extension}"
                mv "$archivo" "$nuevo"
                ((count++))
            fi
        done
        if [ $count -gt 0 ]; then
            msg "Renombrado completado: $count archivo(s)" "SUCCESS"
        else
            msg "No se encontraron archivos para renombrar" "WARNING"
        fi
    fi
    
    pause_continue "Descarga de playlist completada"
}

descargar_audio() {
    local url="$1"
    local solo_audio=$(extraer_url_video "$url")
    
    if verificar_descarga_previa "$solo_audio"; then
        msg "Operaci¨®n cancelada - Audio ya descargado previamente" "INFO"
        return 0
    fi
    
    mostrar_info_video "$solo_audio" || return 1
    
    seleccionar_formato_audio
    
    titulo_audio=$(yt-dlp --get-title "$solo_audio" 2>/dev/null)
    
    if [[ -z "$titulo_audio" ]]; then
        msg "No se pudo obtener el t¨ªtulo del audio. Verifica la URL." "ERROR"
        return 1
    fi
    
    titulo_audio_format=$(string_slugify "$titulo_audio" title)
    
    msg "Iniciando descarga del audio..." "INFO"
    
    local comando="yt-dlp -c -f \"bestaudio\" --extract-audio --audio-format ${FORMATO_AUDIO} --progress --newline -o \"${DOWNLOADS_PATH}/${titulo_audio_format}.%(ext)s\" \"$solo_audio\""
    
    if descargar_con_reintentos "$comando"; then
        file_name_path=$(find "${DOWNLOADS_PATH}" -type f -name "${titulo_audio_format}*" | tail -n 1)
        if [[ -n "$file_name_path" ]]; then
            msg "Fichero de audio descargado en: ${file_name_path}" "SUCCESS"
            guardar_historial "$solo_audio" "$titulo_audio" "AUDIO"
        else
            msg "Audio descargado pero no se encontr¨® el archivo" "WARNING"
        fi
    else
        return 1
    fi
    
    pause_continue "Descarga completada"
}

descargar_por_lotes() {
    echo ""
    echo -e "${BCyan}¨X¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨[${Color_Off}"
    echo -e "${BCyan}¨U${Color_Off}  ${BWhite}?? DESCARGA POR LOTES${Color_Off}              ${BCyan}¨U${Color_Off}"
    echo -e "${BCyan}¨^¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨a${Color_Off}"
    echo ""
    echo -e "${Gray}Crea un archivo de texto con URLs (una por l¨ªnea)${Color_Off}"
    echo -e "${Gray}Ejemplo de archivo 'urls.txt':${Color_Off}"
    echo -e "${Gray}  https://youtube.com/watch?v=...${Color_Off}"
    echo -e "${Gray}  https://youtube.com/watch?v=...${Color_Off}"
    echo ""
    read -p "Ruta del archivo con URLs: " archivo_urls
    
    if [[ ! -f "$archivo_urls" ]]; then
        msg "El archivo no existe: $archivo_urls" "ERROR"
        return 1
    fi
    
    local total_urls=$(grep -c "^https\?://" "$archivo_urls" 2>/dev/null || echo 0)
    
    if [ "$total_urls" -eq 0 ]; then
        msg "No se encontraron URLs v¨¢lidas en el archivo" "ERROR"
        return 1
    fi
    
    msg "Se encontraron $total_urls URLs para descargar" "INFO"
    
    echo ""
    echo -e "${BBlue}?Qu¨¦ tipo de contenido deseas descargar?${Color_Off}"
    echo -e "${BYellow}1)${Color_Off} Videos"
    echo -e "${BYellow}2)${Color_Off} Solo audio"
    read -p "Opci¨®n [1]: " tipo_descarga
    
    if [[ "${tipo_descarga:-1}" == "1" ]]; then
        seleccionar_calidad_video
        configurar_subtitulos
    else
        seleccionar_formato_audio
    fi
    
    local contador=0
    local exitosos=0
    local fallidos=0
    
    while IFS= read -r url || [ -n "$url" ]; do
        [[ -z "$url" || "$url" =~ ^# ]] && continue
        
        ((contador++))
        echo ""
        msg "¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T" "INFO"
        msg "Procesando URL $contador de $total_urls" "INFO"
        msg "¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T" "INFO"
        
        if [[ "${tipo_descarga:-1}" == "1" ]]; then
            if descargar_video "$url"; then
                ((exitosos++))
            else
                ((fallidos++))
            fi
        else
            if descargar_audio "$url"; then
                ((exitosos++))
            else
                ((fallidos++))
            fi
        fi
        
        if [ $contador -lt $total_urls ]; then
            read -p "Presiona ENTER para continuar con la siguiente descarga..."
        fi
        
    done < "$archivo_urls"
    
    echo ""
    msg "¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T" "SUCCESS"
    msg "RESUMEN DE DESCARGA POR LOTES" "SUCCESS"
    msg "¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T" "SUCCESS"
    msg "Total procesadas: $total_urls" "INFO"
    msg "Exitosas: $exitosos" "SUCCESS"
    msg "Fallidas: $fallidos" "ERROR"
    
    pause_continue "Descarga por lotes completada"
}

ver_historial() {
    echo ""
    echo -e "${BCyan}¨X¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨[${Color_Off}"
    echo -e "${BCyan}¨U${Color_Off}  ${BWhite}?? HISTORIAL DE DESCARGAS${Color_Off}          ${BCyan}¨U${Color_Off}"
    echo -e "${BCyan}¨^¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨a${Color_Off}"
    echo ""
    
    if [[ ! -f "$HISTORIAL_FILE" ]]; then
        msg "No hay historial de descargas" "WARNING"
        return 0
    fi
    
    local total_lineas=$(wc -l < "$HISTORIAL_FILE" 2>/dev/null || echo 0)
    
    if [ "$total_lineas" -eq 0 ]; then
        msg "El historial est¨¢ vac¨ªo" "WARNING"
        return 0
    fi
    
    msg "Total de descargas: $total_lineas" "INFO"
    echo ""
    
    echo -e "${Gray}¨²ltimas 10 descargas:${Color_Off}"
    echo -e "${Gray}©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤${Color_Off}"
    
    tail -n 10 "$HISTORIAL_FILE" | while IFS='|' read -r fecha tipo titulo url; do
        echo -e "${BYellow}[$tipo]${Color_Off} ${fecha}"
        echo -e "  ${Gray}${titulo}${Color_Off}"
        echo ""
    done
    
    echo ""
    read -p "?Deseas ver el historial completo? (s/n): " ver_completo
    
    if [[ "$ver_completo" =~ ^[sS]$ ]]; then
        if command -v less &> /dev/null; then
            less "$HISTORIAL_FILE"
        else
            cat "$HISTORIAL_FILE"
        fi
    fi
    
    echo ""
    read -p "?Deseas limpiar el historial? (s/n): " limpiar
    
    if [[ "$limpiar" =~ ^[sS]$ ]]; then
        read -p "??  ?Est¨¢s seguro? Esta acci¨®n no se puede deshacer (s/n): " confirmar
        if [[ "$confirmar" =~ ^[sS]$ ]]; then
            > "$HISTORIAL_FILE"
            msg "Historial limpiado exitosamente" "SUCCESS"
        fi
    fi
}

# =============================================================================
# ?? SECTION: Main Code
# =============================================================================

if ! DATE_HOUR_PE=$(get_date_peru); then
    DATE_HOUR_PE="${DATE_HOUR_PE_DEFAULT}"
fi
set_hours_rest_peru

SO_SYSTEM=$(detect_system)
DOWNLOADS_PATH="${CURRENT_USER_HOME}/Downloads/youtube"

if [ -n "$SO_SYSTEM" ] && [ "$SO_SYSTEM" = "termux" ]; then
    DOWNLOADS_PATH="/storage/emulated/0/Download/youtube"
    mkdir -p $DOWNLOADS_PATH
fi

mkdir -p "$DOWNLOADS_PATH"

# verificar_dependencias

clear

echo ""
echo -e "${BPurple}¨X¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨[${Color_Off}"
echo -e "${BPurple}¨U${Color_Off}  ${BCyan}?? Descarga Videos YouTube${Color_Off}         ${BPurple}¨U${Color_Off}"
echo -e "${BPurple}¨U${Color_Off}         ${BYellow}Versi¨®n ${VERSION_SCRIPT}${Color_Off}              ${BPurple}¨U${Color_Off}"
echo -e "${BPurple}¨d¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨g${Color_Off}"
echo -e "${BPurple}¨U${Color_Off} ${Gray}?? Autor:${Color_Off} ${BWhite}Cesar Auris${Color_Off}               ${BPurple}¨U${Color_Off}"
echo -e "${BPurple}¨U${Color_Off} ${Gray}?? Web:${Color_Off} ${BCyan}solucionessystem.com${Color_Off}        ${BPurple}¨U${Color_Off}"
echo -e "${BPurple}¨^¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨a${Color_Off}"
echo ""

if [ $# -eq 1 ]; then
    url="$1"
    validar_url "$url"
    
    while true; do
        echo -e "${BBlue}Selecciona una opci¨®n:${Color_Off}"
        echo -e "${BYellow}1)${Color_Off} Descargar solo el video"
        echo -e "${BYellow}2)${Color_Off} Descargar playlist completo"
        echo -e "${BYellow}3)${Color_Off} Descargar solo el audio"
        echo -e "${BYellow}4)${Color_Off} Salir"
        read -p "Opci¨®n: " opcion
        
        case $opcion in
            1)
                solicitar_ruta_descarga
                descargar_video "$url"
                exit 0
                ;;
            2)
                solicitar_ruta_descarga
                descargar_playlist "$url"
                exit 0
                ;;
            3)
                solicitar_ruta_descarga
                descargar_audio "$url"
                exit 0
                ;;
            4)
                echo -e "${BRed}Saliendo...${Color_Off}"
                exit 0
                ;;
            *)
                echo -e "${BRed}Opci¨®n no v¨¢lida.${Color_Off}"
                ;;
        esac
    done
else
    while true; do
        echo ""
        echo -e "${BBlue}¨X¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨[${Color_Off}"
        echo -e "${BBlue}¨U${Color_Off}  ${BWhite}MEN¨² PRINCIPAL${Color_Off}                     ${BBlue}¨U${Color_Off}"
        echo -e "${BBlue}¨^¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨T¨a${Color_Off}"
        echo -e "${BYellow}1)${Color_Off} Descargar video individual"
        echo -e "${BYellow}2)${Color_Off} Descargar playlist completo"
        echo -e "${BYellow}3)${Color_Off} Descargar solo audio"
        echo -e "${BYellow}4)${Color_Off} Descargar por lotes (archivo con URLs)"
        echo -e "${BYellow}5)${Color_Off} Ver historial de descargas"
        echo -e "${BYellow}6)${Color_Off} Salir"
        echo ""
        read -p "Opci¨®n: " opcion
        
        case $opcion in
            1|2|3)
                echo ""
                read -p "Ingresa la URL de YouTube: " url
                validar_url "$url"
                solicitar_ruta_descarga
                
                case $opcion in
                    1) descargar_video "$url" ;;
                    2) descargar_playlist "$url" ;;
                    3) descargar_audio "$url" ;;
                esac
                ;;
            4)
                solicitar_ruta_descarga
                descargar_por_lotes
                ;;
            5)
                ver_historial
                pause_continue
                ;;
            6)
                echo -e "${BGreen}?Hasta luego! ??${Color_Off}"
                exit 0
                ;;
            *)
                msg "Opci¨®n no v¨¢lida" "ERROR"
                ;;
        esac
    done
fi